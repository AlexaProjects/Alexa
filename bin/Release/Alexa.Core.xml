<?xml version="1.0"?>
<doc>
    <assembly>
        "Alexa.Core"
    </assembly>
    <members>
        <member name="M:Alexa.Core.GetBoxes2(System.Int32)">
            <summary>
Find boxes in the Alexa Core source image.
</summary>
            <returns> Returns all boxes</returns>
        </member>
        <member name="M:Alexa.Core.GetBoxes(System.Int32)">
            <summary>
Find boxes in the Alexa Core source image.
</summary>
            <returns> Returns all boxes</returns>
        </member>
        <member name="M:Alexa.Core.Release">
            <summary>
Release all objects of Alexa Core
</summary>
        </member>
        <member name="M:Alexa.Core.ReplaceColor(System.Drawing.Bitmap,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Replace color into the Alexa Core source image
</summary>
            <param name="oldR">old red component</param>
            <param name="oldG">old green component</param>
            <param name="oldB">old blue component</param>
            <param name="newR">new red component</param>
            <param name="newG">new green component</param>
            <param name="newB">new blue component</param>
        </member>
        <member name="M:Alexa.Core.BinarizeImage">
            <summary>
Binarize the Alexa Core source image
</summary>
        </member>
        <member name="M:Alexa.Core.FindIcon(System.Drawing.Bitmap,System.Double)">
            <summary>
Find the icon in the Alexa Core source image.
</summary>
            <param name="icon">the icon to find</param>
            <param name="threshold">the threshold</param>
            <returns>Returns the coordinates of the icon</returns>
        </member>
        <member name="M:Alexa.Core.GetInterestPoints">
            <summary>
Find all boxes in the Alexa Core source image.
</summary>
            <returns> Returns all boxes</returns>
        </member>
        <member name="M:Alexa.Core.GetWordsV2(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Find all chars in the Alexa Core source image.
</summary>
            <param name="minHeight">min word height</param>
            <param name="maxHeight">max word height</param>
            <param name="minWidth">min word width</param>
            <param name="maxWidth">max word width</param>
            <returns> Returns all words found</returns>
        </member>
        <member name="M:Alexa.Core.GetWords(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Find all chars in the Alexa Core source image.
</summary>
            <param name="minHeight">min word height</param>
            <param name="maxHeight">max word height</param>
            <param name="minWidth">min word width</param>
            <param name="maxWidth">max word width</param>
            <returns> Returns all words found</returns>
        </member>
        <member name="M:Alexa.Core.GetCharsV2(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Find all chars in the Alexa Core source image.
</summary>
            <param name="lineHeight">line height</param>
            <param name="spaceThickness">space thickness</param>
            <returns> Returns all chars found</returns>
        </member>
        <member name="M:Alexa.Core.GetChars(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Find all chars in the Alexa Core source image.
</summary>
            <param name="lineHeight">line height</param>
            <param name="spaceThickness">space thickness</param>
            <returns> Returns all chars found</returns>
        </member>
        <member name="M:Alexa.Core.GetIconListBoxesV2">
            <summary>
Find all list boxes in the Alexa Core source image.
</summary>
            <returns> Returns all List Boxes found</returns>
        </member>
        <member name="M:Alexa.Core.GetIconListBoxes">
            <summary>
Find all list boxes in the Alexa Core source image.
</summary>
            <returns> Returns all List Boxes found</returns>
        </member>
        <member name="M:Alexa.Core.GetButtonsV2">
            <summary>
Find all buttons in the Alexa Core source image.
</summary>
            <returns> Returns buttons found</returns>
        </member>
        <member name="M:Alexa.Core.GetButtons">
            <summary>
Find all buttons in the Alexa Core source image.
</summary>
            <returns> Returns buttons found</returns>
        </member>
        <member name="M:Alexa.Core.GetInputBoxesV2">
            <summary>
Find all the input boxes in the Alexa Core source image.
</summary>
            <returns> Returns all input boxes found</returns>
        </member>
        <member name="M:Alexa.Core.GetInputBoxes">
            <summary>
Find all the input boxes in the Alexa Core source image.
</summary>
            <returns> Returns all input boxes found</returns>
        </member>
        <member name="M:Alexa.Core.GetGenericBoxesV2(System.Int32,System.Int32,System.Int32)">
            <summary>
Find all the boxes (in the Alexa Core source image) that match the arguments.
</summary>
            <param name="height">height of input box (pixel)</param>
            <param name="width">width of input box (pixel)</param>
            <param name="tollerance">tollerance of height and width (pixel)</param>
            <returns> Returns all input boxes found</returns>
        </member>
        <member name="M:Alexa.Core.GetGenericBoxes(System.Int32,System.Int32,System.Int32)">
            <summary>
Find all the boxes (in the Alexa Core source image) that match the arguments.
</summary>
            <param name="height">height of input box (pixel)</param>
            <param name="width">width of input box (pixel)</param>
            <param name="tollerance">tollerance of height and width (pixel)</param>
            <returns> Returns all input boxes found</returns>
        </member>
        <member name="M:Alexa.Core.SetBrightnessContrast(System.Int32,System.Int32)">
            <summary>
Change brightness and contrast of the Alexa Core source image
</summary>
            <param name="brightness">brightness value</param>
            <param name="contrast">contrast value</param>
        </member>
        <member name="M:Alexa.Core.GetSourceImage">
            <summary>
Get the Alexa Core source image
</summary>
            <returns> Returns the source image</returns>
        </member>
        <member name="M:Alexa.Core.SetDebugFolder(System.String)">
            <summary>
Set the debug folder to save debug image
</summary>
            <param name="path">the path of debug folder</param>
        </member>
        <member name="M:Alexa.Core.EnableDebug(System.Boolean)">
            <summary>
Enable/disable the debug level
</summary>
            <param name="enable">set true to enable debug</param>
        </member>
        <member name="M:Alexa.Core.SetSourceImage(System.Drawing.Bitmap)">
            <summary>
Set the input image of the Alexa Core
</summary>
            <param name="inputImage">the input image</param>
        </member>
        <member name="M:cv.linemod.getDefaultLINEMOD">
 \brief Factory function for detector using LINE-MOD algorithm with color gradients
 and depth normals.

 Default parameter settings suitable for VGA images.

</member>
        <member name="M:cv.linemod.getDefaultLINE">
 \brief Factory function for detector using LINE algorithm with color gradients.

 Default parameter settings suitable for VGA images.

</member>
        <member name="M:cv.linemod.Detector.getTemplates(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
 \brief Get the template pyramid identified by template_id.

 For example, with 2 modalities (Gradient, Normal) and two pyramid levels
 (L0, L1), the order is (GradientL0, NormalL0, GradientL1, NormalL1).

</member>
        <member name="M:cv.linemod.Detector.pyramidLevels">
\brief Get number of pyramid levels used by this detector.

</member>
        <member name="M:cv.linemod.Detector.getT(System.Int32)">
\brief Get sampling step T at pyramid_level.

</member>
        <member name="M:cv.linemod.Detector.getModalities">
 \brief Get the modalities used by this detector.

 You are not permitted to add/remove modalities, but you may dynamic_cast them to
 tweak parameters.

</member>
        <member name="M:cv.linemod.Detector.addSyntheticTemplate(std.vector&lt;cv.linemod.Template&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Add a new object template computed by external means.

</member>
        <member name="M:cv.linemod.Detector.addTemplate(std.vector&lt;cv.Mat&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Rect_&lt;System.Int32&gt;*)">
 \brief Add new object template.

 \param      sources      Source images, one for each modality.
 \param      class_id     Object class ID.
 \param      object_mask  Mask separating object from background.
 \param[out] bounding_box Optionally return bounding box of the extracted features.

 \return Template ID, or -1 if failed to extract a valid template.

</member>
        <member name="M:cv.linemod.Detector.#ctor(std.vector&lt;cv.Ptr&lt;cv.linemod.Modality&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Constructor.

 \param modalities       Modalities to use (color gradients, depth normals, ...).
 \param T_pyramid        Value of the sampling step T at each pyramid level. The
                         number of pyramid levels is T_pyramid.size().

</member>
        <member name="M:cv.linemod.Detector.#ctor">
\brief Empty constructor, initialize with read().

</member>
        <member name="T:cv.linemod.Detector">
\brief Object detector using the LINE template matching algorithm with any set of
modalities.

</member>
        <member name="M:cv.linemod.Match.op_LessThan(cv.linemod.Match!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort matches with high similarity to the front
</member>
        <member name="T:cv.linemod.Match">
\brief Represents a successful template match.

</member>
        <member name="M:cv.linemod.colormap(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Debug function to colormap a quantized image for viewing.

</member>
        <member name="M:cv.linemod.DepthNormal.#ctor(System.Int32,System.Int32,System.UInt32,System.Int32)">
 \brief Constructor.

 \param distance_threshold   Ignore pixels beyond this distance.
 \param difference_threshold When computing normals, ignore contributions of pixels whose
                             depth difference with the central pixel is above this threshold.
 \param num_features         How many features a template must contain.
 \param extract_threshold    Consider as candidate feature only if there are no differing
                             orientations within a distance of extract_threshold.

</member>
        <member name="M:cv.linemod.DepthNormal.#ctor">
\brief Default constructor. Uses reasonable default parameter values.

</member>
        <member name="T:cv.linemod.DepthNormal">
\brief Modality that computes quantized surface normals from a dense depth map.

</member>
        <member name="M:cv.linemod.ColorGradient.#ctor(System.Single,System.UInt32,System.Single)">
 \brief Constructor.

 \param weak_threshold   When quantizing, discard gradients with magnitude less than this.
 \param num_features     How many features a template must contain.
 \param strong_threshold Consider as candidate features only gradients whose norms are
                         larger than this.

</member>
        <member name="M:cv.linemod.ColorGradient.#ctor">
\brief Default constructor. Uses reasonable default parameter values.

</member>
        <member name="T:cv.linemod.ColorGradient">
\brief Modality that computes quantized gradient orientations from a color image.

</member>
        <member name="M:cv.linemod.Modality.create(cv.FileNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Load a modality from file.

</member>
        <member name="M:cv.linemod.Modality.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Create modality by name.

 The following modality types are supported:
 - "ColorGradient"
 - "DepthNormal"

</member>
        <member name="M:cv.linemod.Modality.process(cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Form a quantized image pyramid from a source image.

 \param[in] src  The source image. Type depends on the modality.
 \param[in] mask Optional mask. If not empty, unmasked pixels are set to zero
                 in quantized image and cannot be extracted as features.

</member>
        <member name="T:cv.linemod.Modality">
 \brief Interface for modalities that plug into the LINE template matching representation.

 \todo Max response, to allow optimization of summing (255/MAX) features as uint8

</member>
        <member name="M:cv.linemod.QuantizedPyramid.selectScatteredFeatures(std.vector&lt;cv.linemod.QuantizedPyramid.Candidate&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;cv.linemod.Feature&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.Single)">
 \brief Choose candidate features so that they are not bunched together.

 \param[in]  candidates   Candidate features sorted by score.
 \param[out] features     Destination vector of selected features.
 \param[in]  num_features Number of candidates to select.
 \param[in]  distance     Hint for desired distance between features.

</member>
        <member name="M:cv.linemod.QuantizedPyramid.Candidate.op_LessThan(cv.linemod.QuantizedPyramid.Candidate!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sort candidates with high score to the front
</member>
        <member name="T:cv.linemod.QuantizedPyramid.Candidate">
Candidate feature with a score
</member>
        <member name="M:cv.linemod.QuantizedPyramid.pyrDown">
 \brief Go to the next pyramid level.

 \todo Allow pyramid scale factor other than 2

</member>
        <member name="M:cv.linemod.QuantizedPyramid.extractTemplate(cv.linemod.Template*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Extract most discriminant features at current pyramid level to form a new template.

 \param[out] templ The new template.

</member>
        <member name="M:cv.linemod.QuantizedPyramid.quantize(cv.Mat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
 \brief Compute quantized image at current pyramid level for online detection.

 \param[out] dst The destination 8-bit image. For each pixel at most one bit is set,
                 representing its classification.

</member>
        <member name="T:cv.linemod.QuantizedPyramid">
\brief Represents a modality operating over an image pyramid.

</member>
        <member name="T:cv.linemod.Feature">
@todo Convert doxy comments to rst
\brief Discriminant feature described by its location and label.

</member>
        <member name="T:cvflann.SavedIndexParams">
(Deprecated) Index parameters for creating a saved index.

</member>
        <member name="M:cvflann.log_verbosity(System.Int32)">
Sets the log level used for all flann functions
@param level Verbosity level

</member>
        <member name="M:cvflann.StartStopTimer.reset">
Resets the timer value to 0.

</member>
        <member name="M:cvflann.StartStopTimer.stop">
Stops the timer and updates timer value.

</member>
        <member name="M:cvflann.StartStopTimer.start">
Starts the timer.

</member>
        <member name="M:cvflann.StartStopTimer.#ctor">
Constructor.

</member>
        <member name="F:cvflann.StartStopTimer.value">
Value of the timer.

</member>
        <member name="T:cvflann.StartStopTimer">
 A start-stop timer class.

 Can be used to time portions of code.

</member>
        <member name="F:cvflann.lsh.LshStats.size_histogram_">
Each contained vector contains three value: beginning/end for interval, number of elements in the bin

</member>
        <member name="T:cvflann.lsh.LshStats">
POD for stats about an LSH table

</member>
        <member name="D:cvflann.lsh.Bucket">
A bucket in an LSH table

</member>
        <member name="D:cvflann.lsh.BucketKey">
The id from which we can get a bucket back in an LSH table

</member>
        <member name="D:cvflann.lsh.FeatureIndex">
What is stored in an LSH bucket

</member>
        <member name="T:cvflann.CompositeIndexParams">
Index parameters for the CompositeIndex.

</member>
        <member name="M:cvflann.Logger.log(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)">
Print log message
@param level Log level
@param fmt Message format
@return

</member>
        <member name="M:cvflann.Logger.setDestination(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets the logging destination
@param name Filename or NULL for console

</member>
        <member name="M:cvflann.Logger.setLevel(System.Int32)">
Sets the logging level. All messages with lower priority will be ignored.
@param level Logging level

</member>
        <member name="M:cvflann.UniqueRandom.next">
Return a distinct random integer in greater or equal to 0 and less
than 'n' on each call. It should be called maximum 'n' times.
Returns: a random integer

</member>
        <member name="M:cvflann.UniqueRandom.init(System.Int32)">
Initializes the number generator.
@param n the size of the interval from which to generate random numbers.

</member>
        <member name="M:cvflann.UniqueRandom.#ctor(System.Int32)">
Constructor.
@param n Size of the interval from which to generate
@return

</member>
        <member name="T:cvflann.UniqueRandom">
Random number generator that returns a distinct number from
the [0,n) interval each time.

</member>
        <member name="M:cvflann.rand_int(System.Int32,System.Int32)">
Generates a random integer value.
@param high Upper limit
@param low Lower limit
@return Random integer value

</member>
        <member name="M:cvflann.rand_double(System.Double,System.Double)">
Generates a random double value.
@param high Upper limit
@param low Lower limit
@return Random double value

</member>
        <member name="M:cvflann.seed_random(System.UInt32)">
Seeds the random number generator
 @param seed Random seed

</member>
        <member name="M:cvflann.PooledAllocator.allocateMemory(System.Int32)">
Returns a pointer to a piece of new memory of the given size in bytes
allocated from the pool.

</member>
        <member name="M:cvflann.PooledAllocator.Dispose">
Destructor. Frees all the memory allocated in this pool.

</member>
        <member name="M:cvflann.PooledAllocator.#ctor(System.Int32)">
Default constructor. Initializes a new pool.

</member>
        <member name="M:cvflann.DynamicBitset.test(System.UInt32)">
@param check if a bit is set
     * @param index the index of the bit to check
     * @return true if the bit is set

</member>
        <member name="M:cvflann.DynamicBitset.size">
@param gives the number of contained bits

</member>
        <member name="M:cvflann.DynamicBitset.set(System.UInt32)">
@param set a bit to true
     * @param index the index of the bit to set to 1

</member>
        <member name="M:cvflann.DynamicBitset.resize(System.UInt32)">
@param resize the bitset so that it contains at least size bits
     * @param size

</member>
        <member name="M:cvflann.DynamicBitset.reset_block(System.UInt32)">
@brief sets a specific bit to 0, and more bits too
     * This function is useful when resetting a given set of bits so that the
     * whole bitset ends up being 0: if that's the case, we don't care about setting
     * other bits to 0
     * @param

</member>
        <member name="M:cvflann.DynamicBitset.reset(System.UInt32)">
@brief set one bit to 0
     * @param

</member>
        <member name="M:cvflann.DynamicBitset.reset">
@param set all the bits to 0

</member>
        <member name="M:cvflann.DynamicBitset.empty">
@brief checks if the bitset is empty
     * @return true if the bitset is empty

</member>
        <member name="M:cvflann.DynamicBitset.clear">
Sets all the bits to 0

</member>
        <member name="M:cvflann.DynamicBitset.#ctor(System.UInt32)">
@param only constructor we use in our code
     * @param the size of the bitset (in bits)

</member>
        <member name="M:cvflann.DynamicBitset.#ctor">
@param default constructor

</member>
        <member name="T:cvflann.DynamicBitset">
Class re-implementing the boost version of it
 * This helps not depending on boost, it also does not do the bound checks
 * and has a way to reset a block for speed

</member>
        <member name="M:cvflann.HammingLUT.op_FunctionCall(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
this will count the bits in a ^ b

</member>
        <member name="T:cvflann.HammingLUT">
Hamming distance functor - counts the bit differences between two strings - useful for the Brief descriptor
bit count of A exclusive XOR'ed with B

</member>
        <member name="M:cvflann.load_header(_iobuf*)">

 @param stream - Stream to load from
 @return Index header

</member>
        <member name="T:cvflann.IndexHeader">
Structure representing the index header.

</member>
        <member name="M:cvflann.any.compatible(cvflann.any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if the two types are the same.
</member>
        <member name="M:cvflann.any.reset">
Frees any allocated memory, and sets the value to NULL.
</member>
        <member name="M:cvflann.any.empty">
Returns true if the any contains no value.
</member>
        <member name="M:cvflann.any.swap(cvflann.any*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Utility functions
</member>
        <member name="M:cvflann.any.op_Assign(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Assignment operator, specialed for literal strings.
They have types like const char [6] which don't work as expected.
</member>
        <member name="M:cvflann.any.assign(cvflann.any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment function from another any.
</member>
        <member name="M:cvflann.any.Dispose">
Destructor.
</member>
        <member name="M:cvflann.any.#ctor(cvflann.any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:cvflann.any.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Special initializing constructor for string literals.
</member>
        <member name="M:cvflann.any.#ctor">
Empty constructor.
</member>
        <member name="M:cv.Hamming.op_FunctionCall(System.Byte!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
this will count the bits in a ^ b

</member>
        <member name="M:cv.BriefDescriptorExtractor.info">
@todo read and write for brief
</member>
        <member name="T:cv.StarAdjuster">
An adjuster for StarFeatureDetector, this one adjusts the responseThreshold for now
 * TODO find a faster way to converge the parameters for Star - use CvStarDetectorParams

</member>
        <member name="M:cv.FastAdjuster.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32)">
\param init_thresh the initial threshold to start with, default = 20
     * \param nonmax whether to use non max or not for fast feature detection

</member>
        <member name="T:cv.FastAdjuster">
\brief an adjust for the FAST detector. This will basically decrement or increment the
 * threshold by 1

</member>
        <member name="M:cv.DynamicAdaptedFeatureDetector.#ctor(cv.Ptr&lt;cv.AdjusterAdapter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32)">
\param adjuster an AdjusterAdapter that will do the detection and parameter adjustment
     *  \param max_features the maximum desired number of features
     *  \param max_iters the maximum number of times to try to adjust the feature detector params
     *          for the FastAdjuster this can be high, but with Star or Surf this can get time consuming
     *  \param min_features the minimum desired features

</member>
        <member name="M:cv.AdjusterAdapter.good">
are params maxed out or still valid?
     * \return false if the parameters can't be adjusted any more

</member>
        <member name="M:cv.AdjusterAdapter.tooMany(System.Int32,System.Int32)">
too many features were detected so, adjust the detector params accordingly
     * \param max the maximum number of desired features
     * \param n_detected the number previously detected

</member>
        <member name="M:cv.AdjusterAdapter.tooFew(System.Int32,System.Int32)">
too few features were detected so, adjust the detector params accordingly
     * \param min the minimum number of desired features
     * \param n_detected the number previously detected

</member>
        <member name="M:cv.AdjusterAdapter.Dispose">
pure virtual interface

</member>
        <member name="T:cv.AdjusterAdapter">
\brief A feature detector parameter adjuster, this is used by the DynamicAdaptedFeatureDetector
 *  and is a wrapper for FeatureDetector that allow them to be adjusted after a detection

</member>
        <member name="M:cv.FREAK.selectPairs(std.vector&lt;cv.Mat&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.vector&lt;cv.KeyPoint&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Boolean)">
select the 512 "best description pairs"
         * @param images grayscale images set
         * @param keypoints set of detected keypoints
         * @param corrThresh correlation threshold
         * @param verbose print construction information
         * @return list of best pair indexes

</member>
        <member name="M:cv.FREAK.descriptorType">
returns the descriptor type 
</member>
        <member name="M:cv.FREAK.descriptorSize">
returns the descriptor length in bytes 
</member>
        <member name="M:cv.FREAK.#ctor(System.Boolean,System.Boolean,System.Single,System.Int32,std.vector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor
         * @param orientationNormalized enable orientation normalization
         * @param scaleNormalized enable scale normalization
         * @param patternScale scaling of the description pattern
         * @param nbOctave number of octaves covered by the detected keypoints
         * @param selectedPairs (optional) user defined selected pairs

</member>
        <member name="M:cvSetIdentity(System.Void*,CvScalar)">
* Finds selected eigen values and vectors of a symmetric matrix */
</member>
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Mat!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv.Formatted!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:cv.DynamicAdaptedFeatureDetector'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cvflann.lsh.op_LeftShift(std.basic_ostream<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cvflann.lsh.LshStats!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:cv.linemod.Detector.match(std.vector<cv.Mat>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,std.vector<cv.linemod.Match>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,cv._OutputArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<cv.Mat>!System.Runtime.CompilerServices.IsCon'. -->
    </members>
</doc>